1442.count triplets that can form two arrays of equal xor

Given an array of integers arr.

We want to select three indices i, j and k where (0 <= i < j <= k < arr.length).

Let's define a and b as follows:

a = arr[i] ^ arr[i + 1] ^ ... ^ arr[j - 1]             //A^B=arr[i]+  ......+arr[k]==xor[i,k]=prefix[k+1]^prefix[i]
b = arr[j] ^ arr[j + 1] ^ ... ^ arr[k]                //A^B=0 than prefix[i]==prfix[k+1]
Note that ^ denotes the bitwise-xor operation.

Return the number of triplets (i, j and k) Where a == b.

 

Example 1:

Input: arr = [2,3,1,6,7]
Output: 4
Explanation: The triplets are (0,1,2), (0,2,2), (2,3,4) and (2,4,4)
Example 2:

Input: arr = [1,1,1,1,1]
Output: 10

program1:
class Solution {
    public int countTriplets(int[] arr) {
        int n = arr.length;
        int[] prefix=new int[n+1];
        for(int i=1;i<=n;i++)//prefix[0]=0 so we start from 1 index
        {
            prefix[i]=prefix[i-1]^arr[i-1];//built prfix array of each index
        }
        
        int result=0;
        for(int i=0;i<n;i++)
        {
            for(int k=i+1;k<n;k++)
            {
               if( prefix[i]==prefix[k+1])//prefixsum formula wrt xor prefix[l,r]=prefix[r+1]^prfix[l] 
                     result+=k-i;
            }
        }
        return result;
    }
}
